<script>
 import { onMount } from 'svelte';
 import * as gauss from '../gaussian';
 import * as d3 from 'd3';
 import * as m from 'ml-matrix';
 import {Context} from './util/context';
 import {clamp} from './util/limit';
 import GaussianContours from './GaussianContours.html';

 const magnitude = v => Math.sqrt(v[0] * v[0] + v[1] * v[1]);
 const gaussian1 = new gauss.Gaussian([0,0], [[1,0],[0,2]]);
 const e = new m.EigenvalueDecomposition(gaussian1.cov);
 const l1 = Math.sqrt(e.realEigenvalues[0]);
 const l2 = Math.sqrt(e.realEigenvalues[1]);

 export let eig = {
   e1: {
     x: e.eigenvectorMatrix.get(0,0) * l1,
     y: e.eigenvectorMatrix.get(1,0) * l1,
   },
   e2: {
     x: e.eigenvectorMatrix.get(0,1) * l2,
     y: e.eigenvectorMatrix.get(1,1) * l2
 }};
 export let mean = gaussian1.mean;
 export let context = new Context(300, 300, [-3, 3], [-3, 3]);

 export let gaussian;
 $: {
   const T = new m.Matrix([[eig.e1.x, eig.e2.x], [eig.e1.y, eig.e2.y]]);
   gaussian = new gauss.Gaussian([mean[0],mean[1]], T.mmul(T.transpose()));
 }

 export let e1;
 export let e2;

 onMount(() => {
   d3.select(e1).call(d3.drag()
                        .on('drag', (event, d) => {
                          const { context, eig } = this.get();
                          const k = (eig.e2.x)*(eig.e2.x)+(eig.e2.y)*(eig.e2.y);
                          const x = context.x(clamp(event.x, 10, context.width - 10));
                          const y = context.y(clamp(event.y, 10, context.height - 10));
                          eig.e1 = { x: x, y: y, };
                          eig.e2 = {
                            x: (-y * Math.sqrt(k)) / magnitude([x, y]),
                            y: (x  * Math.sqrt(k)) / magnitude([x, y])
                          };
                          this.set({ eig });
   }));

   d3.select(e2).call(d3.drag()
                        .on('drag', (event, d) => {
                          const { context, eig } = this.get();
                          const k = (eig.e1.x)*(eig.e1.x)+(eig.e1.y)*(eig.e1.y);
                          const x = context.x(clamp(event.x, 10, context.width - 10));
                          const y = context.y(clamp(event.y, 10, context.height - 10));
                          eig.e2 = { x: x, y: y, };
                          eig.e1 = {
                            x: (y * Math.sqrt(k)) / magnitude([x, y]),
                            y: (-x  * Math.sqrt(k)) / magnitude([x, y])
                          };
                          this.set({ eig });
   }));
 });
</script>

<svg width="{context.width}" height="{context.height}">
  <GaussianContours width="{context.width}" height="{context.height}" {context} {gaussian} />
  <circle class="handle"  cx={context.u(eig.e1.x)} cy={context.v(eig.e1.y)} r="4" />
  <circle class="handle"  cx={context.u(eig.e2.x)} cy={context.v(eig.e2.y)} r="4" />
  <line x1={context.u(gaussian.mean[0])} y1={context.v(gaussian.mean[1])} x2={context.u(eig.e1.x)} y2={context.v(eig.e1.y)} stroke="rgb(245, 181, 62)" stroke-width="2" />
  <line x1={context.u(gaussian.mean[0])} y1={context.v(gaussian.mean[1])} x2={context.u(eig.e2.x)} y2={context.v(eig.e2.y)} stroke="rgb(245, 181, 62)" stroke-width="2" />
  <circle class="handleInvisible" bind:this={e1} cx={context.u(eig.e1.x)} cy={context.v(eig.e1.y)} r="44" />
  <circle class="handleInvisible" bind:this={e2} cx={context.u(eig.e2.x)} cy={context.v(eig.e2.y)} r="44" />
</svg>

<style>
  .handleInvisible {
    fill: rgba(245, 181, 62, 0);
    cursor: grab;
  }

  .handle {
    fill: rgb(245, 181, 62);
  }

  .handle:hover {
    stroke: gray;
    stroke-width: 2px;
  }
</style>
